# Exercises Chp 10

#### 10.1 In this and the following exercises in this chapter, we're going to be doing some lightweight database modelling work for a fictional beach equipment rental business. Your answers may deviate a little from mine as we go, and that's fine - database design is a quite subjective topic. To kick things off, we'll keep working with our existing database but we want to create all our tables within a schema called 'beach'. Write a SQL statement to create the 'beach' schema.

```sql
create schema beach;
```

#### 10.2 Create a table to store customers. For each customer we want to capture their first name, last name, email address, phone number, and the date the account was created. Don't worry about primary keys and constraints for now - just focus on the create statement and choosing what you think are appropriate data types for the listed attributes.

The text data type is actually ideal for the email, first name, and last name. When it comes to PostgreSQL, you should typically prefer to use text instead of varchar(n) - there's no performance difference, and unless you have a good reason to want to set a maximum length just use text (you can also set a maximum length with text via a CHECK constraint - and more too!). For the phone number, you could get more fancy and try to denormalize it further in to a few columns (for international dialing prefix, number, extension, etc.) but it's awfully complicated and there are many exceptions and edge cases. text is the more flexible approach. The create date can be of type date - we don't need a time component. 

```sql
create table beach.customers (
  email text,
  first_name text,
  last_name text,
  phone text,
  create_date date
);
```

#### 10.3 Create a table to store details about the equipment to be rented out. For each item, we want to store the type ('surf board', 'kayak', etc.), a general ad-hoc description of the item (color, brand, condition, etc), and replacement cost so we know what to charge customers if they lose the item.

Both the item type and description can be text. Because the business will be only stocking certain types of items, in a future exercise we'll investigate ways to restrict the item_type just to particular values. The replacement cost is an interesting one - PostgreSQL actually does actually have a [money data type](https://www.postgresql.org/docs/current/datatype-money.html) that should in theory be ideal. In practice though, it has a range of problems you can read about online and so numeric is the better choice. I've opted for a precision of 7 and scale of 2, which allows storing items of up to value $99,999.99 which seems more than adequate! 

```sql
create table beach.equipment (
  item_type text,
  description text,
  replacement_cost numeric(7, 2)
);
```

#### 10.4 After running the business for a while, we notice that customers sometimes lose equipment. Write a SQL statement to alter the equipment table (assume it already has data in it we don't want to lose) to add a column to track whether the item is missing.

You can use the ALTER TABLE statement to add a column to an existing table. In this case, we add the column missing to be of type boolean. 

```sql
alter table beach.equipment
  add missing boolean;
```

#### 10.5 Add a surrogate primary key for the customers table using the GENERATED AS IDENTITY syntax (we assume not all customers will provide an email address or phone number ruling them out as potential natural keys). Note you may drop the schema/table and re-create it from scratch.

We introduce a new surrogate key column called customer_id of type bigint (though int would likely be fine too since this is just a small beach rental business). In a challenge exercise at the end of this chapter, we'll explore what makes GENERATED ALWAYS... different from GENERATED BY DEFAULT... 

```sql
create table beach.customers (
  customer_id bigint generated always as identity primary key,
  email text,
  first_name text,
  last_name text,
  phone text,
  create_date date
);
```

#### 10.6 Add a surrogate primary key for the equipment table using one of the serial types. Also add in to the table definition the 'missing' column from exercise 10.4. Note you may drop the schema/table and re-create it from scratch.

```sql
create table beach.equipment (
  equipment_id bigserial primary key,
  item_type text,
  description text,
  replacement_cost numeric(7, 2),
  missing boolean
);
```

#### 10.7 Create a new table to store information about each rental with an appropriate primary key. For each rental, store the customer, the item that was rented, the rental date, and the return date.

We'll assume for now that a rental consists of just renting one item (and revisit this in the challenge exercises) so we can define our primary key to be a composite natural key comprising the customer ID, equipment ID, and rental date. The combination of all 3 should be unique - we include the rental date in the key to allow the very plausible scenario of the same customer renting the same item on some other day. 

```sql
create table beach.rentals (
  customer_id bigint,
  equipment_id bigint,
  rental_date date,
  return_date date,
  primary key (customer_id, equipment_id, rental_date)
);
```

#### 10.8 Add appropriate foreign keys to the rentals table. Setup the foreign keys such that if the referenced customer or equipment is deleted, the related entries in the rentals table will also be deleted. Note you may drop the schema/table and re-create it from scratch.

Both the customer ID and equipment ID can be setup as foreign keys with ON DELETE CASCADE specified to ensure deletion of any referenced customers or equipment cascade delete records in the rentals table. 

```sql
create table beach.rentals (
  customer_id bigint references beach.customers (customer_id) on delete cascade,
  equipment_id bigint references beach.equipment (equipment_id) on delete cascade,
  rental_date date,
  return_date date,
  primary key (customer_id, equipment_id, rental_date)
);
```

#### 10.9 Add appropriate check, unique, not null, and default constraints to the customers table to capture the following requirements: a) A customer must provide both a first name and last name b) A customer must provide at least one contact detail - a phone number or email address c) The create date should be the date the new customer record is inserted in the table d) No two customers should have the same email address or phone number

You shouldn't have too much problem picking constraints for the above requirements. Two interesting ones worth focusing on are the default create date - in this case, we use the function [current_date](https://www.postgresql.org/docs/current/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT) (oddly enough, a function that you can call without parentheses) to return the current date. Also the check constraint, to make sure that either the email or phone number is not null. 

```sql
create table beach.customers (
  customer_id bigint generated always as identity primary key,
  email text unique,
  first_name text not null,
  last_name text not null,
  phone text unique,
  create_date date not null default current_date,
  check (email is not null or phone is not null)
);
```

#### 10.10 Add appropriate check, unique, not null, and default constraints to the equipment table to capture the following requirements: a) A newly added item should not be missing! b) Each item must have a type c) The replacement cost can be NULL. But if provided, it must be a positive number

You might be wondering about the check constraint for replacement_cost and why you didn't have to explicitly permit null. It's always important to keep in mind the '3 valued' logic employed by SQL where an expression can evaluate to true, false, or unknown. On inserting a replacement cost of NULL, the comparison "Is NULL >= 0" evaluates to unknown. Check constraints reject values that evaluate to false, but unknown is fair game. Which in this case, is exactly what we want.

```sql
create table beach.equipment (
  equipment_id bigserial primary key,
  item_type text not null,
  description text,
  replacement_cost numeric(7, 2) check (replacement_cost >= 0),
  missing boolean not null default false
);
```

#### 10.11 Search the official PostgreSQL documentation for information about GENERATED { ALWAYS | BY DEFAULT } and explain in your own words the difference between the two options.

With BY DEFAULT, PostgreSQL will generate a unique value for the column on insert, but will also allow you to insert your own value if you want to manually take control. With ALWAYS, if you attempt to provide your own value for the column as part of the insert statement, you'll get an error. 

#### 10.12 Imagine you wanted to restrict the equipment types to just a couple of options like 'Surfboard', 'Single Kayak', 'Double Kayak', etc. To do this, you actually have more options at your disposal than you might think. You could add a check constraint to the column. You could create an ENUM. You could create a whole new data type called a DOMAIN. Or you could use a new table in your database to store the available types. Have a read of [this article](https://www.commandprompt.com/blog/fk_check_enum_or_domain_that_is_the_question/) and justify which approach you would take in this case.

The approach I would take is to store the types in their own table with the type defined as the primary key. The main reason for preferring this approach is because it would be reasonable to expect new types of equipment to be added over time. When this happens, rather than having to alter constraints, drop the enum type and recreate, etc. and all the other complicated approaches, managing the types in their own table would be very easy with simple INSERT statements. We could also easily produce a list of all the different types available for rent, etc. 

```sql
create table equipment_types (
  type text primary key
);
```

#### 10.13 A customer comes in and asks whether there are any Single Kayak's available for rent. Write a query to return a count of how many Single Kayak's are available for rent.

In this case, the query is written to perform a count of items with the type 'Single Kayak', that are not missing, and also are not actively being rented (where an active rental is defined as a rental with a NULL return date). 

```sql
select count(*)
from beach.equipment
where item_type = 'Single Kayak'
  and missing = false
  and equipment_id not in
    (select equipment_id
     from beach.rentals
     where return_date is null);
```

#### 10.14 Right now a rental consists of a customer renting a single item. If it were more common though for a customer to rent multiple items at a time and you wanted to capture these all under a single 'rental', how would you modify the existing tables (or create new tables) to model this.

One approach could be to split out the equipment being rented in to its own table. So as shown below, the rental_details table would capture details about the items, and could contain multiple entries for each rental ID. 

```sql
create table beach.rentals (
  rental_id bigserial primary key,
  customer_id bigint references beach.customers (customer_id),
  rental_date date,
  return_date date
);

create table beach.rental_details (
  rental_id bigint references beach.rentals (rental_id),
  equipment_id bigint references beach.equipment (equipment_id),
  primary key (rental_id, equipment_id)
);
```
